<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <title>Advanced Room</title>
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">
    <style>
      @import url(http://fonts.googleapis.com/earlyaccess/notosansjapanese.css);

      body {
        font-family: 'Noto Sans Japanese', sans-serif;
      }

      a {
        text-decoration: none;
        color: blue;
      }

      a:visited {
        color: blue;
      }

      a:hover {
        text-decoration: underline;
      }

      li {
        line-height: 1.8;
      }

      h1, h2, h3 {
        font-weight: bold;
      }

      /* ページ番号 */
      .remark-slide-number {
        color: #CCCCCC;
        font-size: 12pt;
        opacity: 1;
      }

      .hero {
        background-color: var(--bg-color);
        color: #fff;
      }

      .hero h1, .hero h2, .hero h3 {
        color: #FFFFFF;
      }

      .normal {
        background-image:
        url("../android-icon-72x72.png"),
        linear-gradient(180deg, var(--bg-color) 40%, #FFFFFF 40%);
        background-position:
        right 0.4em bottom 1em,
        right 0em bottom 8em;
      }

      .nologo {
        background-image: linear-gradient(180deg, var(--bg-color) 40%, #FFFFFF 40%);
      }

      .normal h1 {
        color: white;
        margin-top: 0px;
        margin-bottom: 1em;
        font-size: 24pt;
      }

      .normal h1 a {
        color: white;
      }

      .condensed h1 {
        transform: scaleX(0.75);
        transform-origin: left top;
        white-space: nowrap;
      }

      .normal h2 {
        margin: 0px;
        font-size: 20pt;
      }

      .normal {
        font-size: 18pt;
      }

      .faq {
        background-color: var(--bg-color);
        font-size: 20pt;
        color: #fff;
      }

      .faq h1 {
        font-size: 28pt;
      }

      .faq a {
        color: #fff;
      }

      .remark-code, .remark-inline-code {
        font-family: monospace;
      }

      code {
        border-radius: 4px;
        max-height: 580px;
      }

      .hljs-googlecode .hljs {
        background-color: #EEEEEE;
        overflow-y: auto;
        overflow-x: hidden;
      }

      .level {
        position: absolute;
        top: 20px;
        right: 20px;
        padding: 10px 20px;
        background-color: #fff;
        color: var(--bg-color);
      }

      .level::before {
        content: "API レベル: ";
      }

      img {
        float: right;
        margin-left: 1em;
        max-width: 40%;
        max-height: 40%;
      }

      video {
        float: right;
        margin-left: 1em;
        max-width: 32%;
        max-height: 32%;
      }

      .large img {
        float: none;
        max-width: 70%;
        max-height: 100%;
      }

      .large video {
        float: none;
        max-width: 90%;
        max-height: 100%;
      }

      .small {
        font-size: 16pt;
      }

      .tiny {
        font-size: 14pt;
      }

      .small img {
        margin-top: 30%;
        max-width: 20%;
        max-height: 20%
      }

      .card .medium img {
        float: right;
        margin-left: 1em;
        max-width: 70%;
        max-height: 70%;
      }

      .chapter-1 {
        --bg-color: #2196F3;
      }

      .chapter-2 {
        --bg-color: #3F51B5;
      }

      .chapter-3 {
        --bg-color: #009688;
      }

      .chapter-4 {
        --bg-color: #FF5722;
      }

      .chapter-5 {
        --bg-color: #F44336;
      }

      .chapter-6 {
        --bg-color: #E91E63;
      }

      .chapter-7 {
        --bg-color: #9C27B0;
      }

      .chapter-8 {
        --bg-color: #EF6C00;
      }

      .chapter-9 {
        --bg-color: #673AB7;
      }

      .chapter-10 {
        --bg-color: #607D8B;
      }

      .chapter-11 {
        --bg-color: #039BE5;
      }

      .chapter-12 {
        --bg-color: #00838F;
      }

      .chapter-13 {
        --bg-color: #43A047;
      }

      .chapter-14 {
        --bg-color: #757575;
      }

      .chapter-15 {
        --bg-color: #827717;
      }

      .chapter-16 {
        --bg-color: #795548;
      }

      .chapter-17 {
        --bg-color: #689F38;
      }

      table {
        width:100%;
        border-collapse: separate;
        border-spacing: 0px;
      }

      th {
        padding: 6px;
        background-color: #eee;
        border: 1px solid #b9b9b9;
      }

      td {
        padding: 6px;
        background-color: #fff;
        border: 1px solid #b9b9b9;
      }

    </style>
  </head>
  <body>
    <textarea id="source">
class: chapter-1, hero, center, middle

# <nobr>Advanced Room</nobr>

## GDG DevFest Tokyo 2018

2018/09/01

荒木佑一

---

class: chapter-2, normal

# Room とは

![Jetpack](jetpack-hero.svg)

Android の SQLite データベースを使いやすくするライブラリ

アノテーション プロセッサーを利用することで冗長な処理を自動生成

SQL をビルド時に検証

LiveData によるテーブルの監視

マイグレーション

RxJava サポート

---

class: chapter-2, normal

# Entity

```kotlin
@Entity
data class Cheese(
    @PrimaryKey
    val id: Long,
    val name: String,
    val favorite: Boolean)
```

Room が自動的に対応するスキーマのテーブルを作成

```sql
CREATE TABLE IF NOT EXISTS Cheese (
  id INTEGER NOT NULL,
  name TEXT NOT NULL,
  favorite INTEGER NOT NULL,
  PRIMARY KEY(id))
```

---

class: chapter-2, normal

# DAO

SQL と Java/Kotlin の世界の橋渡し

```kotlin
@Dao
interface CheeseDao {
    @Query("SELECT * FROM Cheese")
    fun all(): LiveData&lt;List&lt;Cheese&gt;&gt;

    @Query("SELECT * FROM Cheese WHERE id = :id")
    fun byId(id: Long): LiveData&lt;Cheese?&gt;

    @Query("SELECT COUNT(*) FROM Cheese")
    fun count(): Int

    @Insert
    fun insertAll(cheeses: List&lt;Cheese&gt;)
}
```

---

class: chapter-2, normal

# Room の基本を学ぶには

Room Persistence Library<br>
[http://d.android.com/topic/libraries/architecture/room](https://developer.android.com/topic/libraries/architecture/room)

7 Steps To Room<br>
[https://medium.com/androiddevelopers/7-steps-to-room-27a5fe5f99b2](https://medium.com/androiddevelopers/7-steps-to-room-27a5fe5f99b2)

Room - Architecture Components 勉強会 #4<br>
[http://yaraki.github.io/slides/aac-room/index.html](http://yaraki.github.io/slides/aac-room/index.html)

---

class: chapter-3, normal

# 書き込み

```kotlin
@Entity
data class Author(@PrimaryKey val id: Long, val name: String)
```

```kotlin
@Dao
interface AuthorDao {
    @Insert
    fun insert(author: Author)
}
```

```kotlin
@Database(entities = [Author::class], version = 1)
abstract class LiteratureDatabase : RoomDatabase() {
    abstract fun author(): AuthorDao
}
```

```kotlin
db.author().insert(Author(1L, "芥川龍之介"))
```

---

class: chapter-3, normal

# 複数 書き込み 

配列で

```kotlin
    @Insert
    fun insertArray(authors: Array&lt;Author&gt;)

    @Insert
    fun insertVararg(vararg authors: Author)
```

リスト、セットで

```kotlin
    @Insert
    fun insertList(authors: List&lt;Author&gt;)

    @Insert
    fun insertSet(authors: Set&lt;Author&gt;)
```

???

- どんなコレクションが使える？

---

class: chapter-3, normal

# 複数 書き込み

`Iterable` なコレクションであれば使える

```kotlin
    @Insert
    fun insertAll(authors: Iterable&lt;Author&gt;)
```

@Update および @Delete でも同様

自動的にトランザクションで囲われる<br>
= 主キーが重複すればエラーでロールバック

複数種類でも大丈夫

```kotlin
    @Insert
    fun insertAuthorAndBook(author: Author, book: Book)
```

---

class: chapter-3, normal

# UPSERT

サーバーと同期するとき

主キーが重複するときは上書き

```kotlin
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    fun insertAll(authors: List&lt;Author&gt;)
```

```kotlin
    db.author().insertAll(listOf(
            Author(1L, "夏目"),
            Author(2L, "森鴎外")))
    // db には 2 件

    db.author().insertAll(listOf(
            Author(1L, "夏目漱石"),
            Author(3L, "芥川龍之介")))
    // db には 3 件
```

---

class: chapter-3, normal

# 更新、削除

```kotlin
    @Update
    fun update(author: Author)

    @Delete
    fun delete(author: Author)
```

引数の配列やリストの扱いは @Insert と同様

@Query でも UPDATE/DELETE はできる

```kotlin
    @Query("UPDATE Author SET name = :name WHERE id = :id")
    fun rename(id: Long, name: String)

    @Query("DELETE FROM Author WHERE id = :id")
    fun delete(id: Long)
```

---

class: chapter-3, normal

# @Query で複数削除

```kotlin
    @Query("DELETE FROM Author WHERE id IN (:ids)")
    fun deleteAll(ids: List&lt;Long&gt;)
```

Room が自動的に複数パラメーターを展開

ただし 999 個まで

---

class: chapter-5, normal

# 外部キー制約

```kotlin
@Entity
data class Author(@PrimaryKey val id: Long, val name: String)

@Entity(
        foreignKeys = [
            ForeignKey(
                    entity = Author::class,
                    childColumns = ["authorId"],
                    parentColumns = ["id"])],
        indices = [Index("authorId")])
data class Book(
        @PrimaryKey
        val id: Long,
        val title: String,
        val authorId: Long
)
```

---

class: chapter-5, normal

# 外部キー制約エラー

```kotlin
    db.author().insertAll(listOf(
            Author(id = 1L, name = "芥川")))

    db.book().insertAll(listOf(
            Book(id = 1L, title = "芋粥", authorId = 1L),
            Book(id = 2L, title = "お伽草紙", authorId = 2L)))
```

SQLiteConstraintException で トランザクションはロールバックされる

順番を守って挿入しないといけない

---

class: chapter-5, normal

# 外部キー制約エラー？

```kotlin
    db.runInTransaction {

        db.book().insertAll(listOf(
                Book(id = 1L, title = "芋粥", authorId = 1L),
                Book(id = 2L, title = "お伽草紙", authorId = 2L)))

        db.author().insertAll(listOf(
                Author(id = 1L, name = "芥川"),
                Author(id = 2L, name = "太宰")))

    }
```

---

class: chapter-5, normal

# 外部キー制約を一時的に保留

```kotlin
    val sqlite = db.openHelper.writableDatabase

    db.runInTransaction {

        `sqlite.execSQL("PRAGMA defer_foreign_keys = TRUE")`

        db.book().insertAll(listOf(
                Book(id = 1L, title = "芋粥", authorId = 1L),
                Book(id = 2L, title = "お伽草紙", authorId = 2L)))

        db.author().insertAll(listOf(
                Author(id = 1L, name = "芥川"),
                Author(id = 2L, name = "太宰")))

    }
```

.small[Kitkat 以前では `PRAGMA foreign_keys = FALSE` しておいて、終わってから `PRAGMA foreign_keys = TRUE` する]

???

- ただし defer_foreign_keys は Lollipop 以降

---

class: chapter-7, normal

# 必要な情報だけ取ってくる

```kotlin
@Entity
data class Author(
        @PrimaryKey
        val id: Long,
        val name: String,
        val dateOfBirth: Date,
        val dateOfDeath: Date,
        val placeOfBirth: String,
        val description: String,
        /* まだまだ続く */
)
```

```kotlin
    @Query("SELECT * FROM Author")
    fun liveAll(): LiveData&lt;List&lt;Author&gt;&gt;
```

一覧画面で必要なのは ID と名前だけ

---

class: chapter-7, normal

# POJO

```kotlin
// @Entity ではない
data class AuthorSummary(
        val id: Long,
        val name: String
)
```

```kotlin
    @Query("SELECT id, name FROM Author")
    fun liveAll(): LiveData&lt;List&lt;`AuthorSummary`&gt;&gt;
```

テーブル監視も正しく動く

カラムの名前と型が一致していれば、返す値は Entity でなくて良い

---

class: chapter-7, normal

# POJO

```kotlin
data class BookWithAuthorName(
        val id: Long,
        val title: String,
        val authorId: Long,
        val authorName: String
)
```

```kotlin
    @Query("""
        SELECT
            Book.id
          , Book.title
          , Book.authorId
          , Author.name AS authorName
        FROM Book
        INNER JOIN Author ON Book.authorId = Author.id
    """)
    fun liveAllWithAuthor(): LiveData&lt;List&lt;BookWithAuthorName&gt;&gt;
```

---

class: chapter-7, normal

# @Relation

```kotlin
data class AuthorWithBooks(
        @Embedded
        val author: Author) {
    @Relation(entity = Book::class,
              parentColumn = "id",
              entityColumn = "authorId")
    lateinit var books: List&lt;Book&gt;
}
```

```kotlin
    @Transaction
    @Query("SELECT * FROM Author WHERE id = :id")
    fun byIdWithBooks(id: Long): AuthorWithBooks?
```

以下の SQL が @Relation の中に入る

```sql
SELECT * FROM Book WHERE authorId IN (:id)
```

---

class: chapter-7, normal

# @Relation

```kotlin
data class AuthorWithBooks(
        @Embedded
        val author: Author) {
    @Relation(entity = Book::class,
              parentColumn = "id",
              entityColumn = "authorId")
    `lateinit var` books: List&lt;Book&gt;
}
```

```kotlin
data class AuthorWithBooks(
        @Embedded
        val author: Author,
        @Relation(entity = Book::class,
                  parentColumn = "id",
                  entityColumn = "authorId")
        val books: List&lt;Book&gt;
)
```

???

- 現在は @Relation の付くフィールドは var でないといけない
- バージョン 2.1 から val でも大丈夫になる

---

class: chapter-8, normal

# テスト

```kotlin
@RunWith(AndroidJUnit4::class)
@SmallTest
class AuthorDaoTest {
    private lateinit var db: LiteratureDatabase

    @Before
    fun openDatabase() {
        db = Room.`inMemoryDatabaseBuilder`(
                        InstrumentationRegistry.getTargetContext()
                        LiteratureDatabase::class.java)
                 .build()
    }

    @Test
    fun author() {
        db.author().insert(Author(1L, "芥川"))
        assertThat(db.author().byId(1L)!!, \`is`(equalTo(Author(1L, "芥川"))))
    }
}
```

---

class: chapter-8, normal

# LiveData のテスト

```kotlin
    @Test
    fun liveAuthor() {
        db.author().insert(Author(1L, "芥川"))
        assertThat(db.author().`liveById(1L).value`,
                   \`is`(equalTo(Author(1L, "芥川"))))
    }
```

→ null

どうにかして待ち合わせる必要がある

---

class: chapter-8, normal

# InstantTaskExecutorRule

```gradle
    androidTestImplementation 'android.arch.core:core-testing:1.1.1'
```

```kotlin
class AuthorDaoTest {
    `@get:Rule val executorRule = InstantTaskExecutorRule()`
    
    @Test
    fun liveAuthor() {
        db.author().insert(Author(1L, "芥川"))
        val liveData = db.author().liveById(1L)
        liveData.observeForever(object : Observer&lt;Author&gt; {
            override fun onChanged(t: Author?) {
                assertThat(t, \`is`(equalTo(Author(1L, "芥川"))))
                liveData.removeObserver(this)
            }
        })
    }
}
```

```kotlin
    db = Room.inMemoryDatabaseBuilder(context, LiteratureDatabase::class.java)
        .`allowMainThreadQueries`().build()
```

---

class: chapter-8, normal

# Mockito

```kotlin
    @Test
    fun testLiveData() {
        db.author().insert(Author(1L, "芥川"))

        @Suppress("UNCHECKED_CAST")
        val observer = mock(Observer::class.java) as Observer&lt;Author&gt;

        val liveData = db.author().liveById(1L)
        InstrumentationRegistry.getInstrumentation().runOnMainSync {
            liveData.observeForever(observer)
        }

        verify(observer, timeout(300L).atLeastOnce())
            .onChanged(eq(Author(1L, "芥川")))

        InstrumentationRegistry.getInstrumentation().runOnMainSync {
            liveData.removeObserver(observer)
        }
    }
```

???

- ちょっと遅い

---

class: chapter-8, normal

# CountDownLatch

```kotlin
    @Test
    fun testLiveData() {
        db.author().insert(Author(1L, "芥川"))
        assertThat(db.author().liveById(1L).`await`(),
                   \`is`(equalTo(Author(1L, "芥川"))))
    }

    private fun &lt;T&gt; LiveData&lt;T&gt;.await(): T {
        val latch = CountDownLatch(1)
        val result = AtomicReference&lt;T&gt;()
        InstrumentationRegistry.getInstrumentation().runOnMainSync {
            observeForever(object : Observer&lt;T&gt; {
                override fun onChanged(t: T?) {
                    if (t != null) {
                        result.set(t)
                        removeObserver(this)
                    } } })
        }
        latch.await(300L, TimeUnit.MILLISECONDS)
        return result.get()
    }
```

---

class: chapter-16, normal

# [予定] インスタンス間の監視

複数のデータベース インスタンス間でテーブル変更を通知し合う

```kotlin
val db = Room.databaseBuilder(context, LiteratureDatabase.class, "l.db")
             .`enableMultiInstanceInvalidation()`
             .build()
```

プロセスをまたいでも OK

---

class: chapter-16, normal

# [予定] View

```kotlin
@DatabaseView("""
    SELECT
        Book.id
      , Book.name
      , Book.authorId
      , Author.name AS authorName
    FROM
        Book INNER JOIN Author ON Book.authorId = Author.id
""")
data class BookDetail(
        val id: Long,
        val name: String,
        val authorId: Long,
        val authorName: String
)
```

```kotlin
    @Query("SELECT * FROM BookDetail WHERE id = :id")
    fun detailById(id: Long): BookDetail?
```

---

class: chapter-17, normal

# まとめ

不具合報告・要望は [issuetracker.google.com](https://issuetracker.google.com/issues/new?component=192731&template=842428) から

[AOSP AndroidX Contribution Guide](https://android.googlesource.com/platform/frameworks/support/+/androidx-master-dev/README.md)

---

class: chapter-17, hero, middle, center

# ありがとうございました

    </textarea>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js">
    </script>
    <script>
      var hljs = remark.highlighter.engine;
    </script>
    <script src="http://gnab.github.io/remark/remark.language.js"></script>
    <script>
      var slideshow = remark.create({
        ratio: '4:3',
        highlightStyle: 'googlecode',
        highlightLanguage: 'remark',
        highlightLines: true,
        highlightSpans: true,
        navigation: {
          click: false,
          scroll: false,
          touch: true
        }
      });
    </script>
  </body>
</html>  
