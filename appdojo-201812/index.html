<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <title>Jetpack 最新情報</title>
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">
    <style>
      @import url(http://fonts.googleapis.com/earlyaccess/notosansjapanese.css);

      body {
        font-family: 'Noto Sans Japanese', sans-serif;
      }

      a {
        text-decoration: none;
        color: blue;
      }

      a:visited {
        color: blue;
      }

      a:hover {
        text-decoration: underline;
      }

      li {
        line-height: 1.8;
      }

      h1, h2, h3 {
        font-weight: bold;
      }

      /* ページ番号 */
      .remark-slide-number {
        color: #CCCCCC;
        font-size: 12pt;
        opacity: 1;
      }

      .hero {
        background-color: var(--bg-color);
        color: #fff;
      }

      .hero h1, .hero h2, .hero h3 {
        color: #FFFFFF;
      }

      .normal {
        background-image:
        url("appdojo.png"),
        linear-gradient(180deg, var(--bg-color) 40%, #FFFFFF 40%);
        background-position:
        right 0em bottom 1.7em,
        right 0em bottom 8em;
      }

      .nologo {
        background-image: linear-gradient(180deg, var(--bg-color) 40%, #FFFFFF 40%);
      }

      .normal h1 {
        color: white;
        margin-top: 0px;
        margin-bottom: 1em;
        font-size: 24pt;
      }

      .normal h1 a {
        color: white;
      }

      .condensed h1 {
        transform: scaleX(0.75);
        transform-origin: left top;
        white-space: nowrap;
      }

      .normal h2 {
        margin: 0px;
        font-size: 20pt;
      }

      .normal {
        font-size: 18pt;
      }

      .faq {
        background-color: var(--bg-color);
        font-size: 20pt;
        color: #fff;
      }

      .faq h1 {
        font-size: 28pt;
      }

      .faq a {
        color: #fff;
      }

      .remark-code, .remark-inline-code {
        font-family: monospace;
      }

      code {
        border-radius: 4px;
        max-height: 580px;
      }

      .hljs-googlecode .hljs {
        background-color: #EEEEEE;
        overflow-y: auto;
        overflow-x: hidden;
      }

      .version {
        position: absolute;
        top: 13px;
        right: 20px;
        padding: 10px 20px;
        background-color: #fff;
        color: var(--bg-color);
      }

      .level {
        position: absolute;
        top: 20px;
        right: 20px;
        padding: 10px 20px;
        background-color: #fff;
        color: var(--bg-color);
      }

      .level::before {
        content: "API レベル: ";
      }

      img {
        float: right;
        margin-left: 1em;
        max-width: 40%;
        max-height: 40%;
      }

      video {
        float: right;
        margin-left: 1em;
        max-width: 32%;
        max-height: 32%;
      }

      .center img {
        float: none;
        max-width: 40%;
        max-height: 40%;
      }

      .large img {
        float: none;
        text-align: center;
        max-width: 70%;
        max-height: 100%;
      }

      .large video {
        float: none;
        max-width: 90%;
        max-height: 100%;
      }

      .small {
        font-size: 16pt;
      }

      .tiny {
        font-size: 14pt;
      }

      .small img {
        max-width: 30%;
        max-height: 30%
      }

      .card .medium img {
        float: right;
        margin-left: 1em;
        max-width: 70%;
        max-height: 70%;
      }

      .chapter-1 {
        --bg-color: #2196F3;
      }

      .chapter-2 {
        --bg-color: #3F51B5;
      }

      .chapter-3 {
        --bg-color: #009688;
      }

      .chapter-4 {
        --bg-color: #FF5722;
      }

      .chapter-5 {
        --bg-color: #F44336;
      }

      .chapter-6 {
        --bg-color: #E91E63;
      }

      .chapter-7 {
        --bg-color: #9C27B0;
      }

      .chapter-8 {
        --bg-color: #EF6C00;
      }

      .chapter-9 {
        --bg-color: #673AB7;
      }

      .chapter-10 {
        --bg-color: #607D8B;
      }

      .chapter-11 {
        --bg-color: #039BE5;
      }

      .chapter-12 {
        --bg-color: #00838F;
      }

      .chapter-13 {
        --bg-color: #43A047;
      }

      .chapter-14 {
        --bg-color: #757575;
      }

      .chapter-15 {
        --bg-color: #827717;
      }

      .chapter-16 {
        --bg-color: #795548;
      }

      .chapter-17 {
        --bg-color: #689F38;
      }

      table {
        width:100%;
        border-collapse: separate;
        border-spacing: 0px;
      }

      th {
        padding: 6px;
        background-color: #eee;
        border: 1px solid #b9b9b9;
      }

      td {
        padding: 6px;
        background-color: #fff;
        border: 1px solid #b9b9b9;
      }

    </style>
  </head>
  <body>
    <textarea id="source">
class: chapter-1, hero, center, middle

# Jetpack 最新情報</nobr>

## Google Play APP DOJO

2018/12/18

荒木佑一

---

class: chapter-1, normal

# 自己紹介

荒木佑一

@yuichi_araki

Developers Programs Engineer @ Google

- androidx.transition
- androidx.room
- Android のサンプル ([d.android.com/samples](https://developers.android.com/samples))
- Google I/O アプリ
- Santa Tracker (サンタを追いかけよう) Android アプリ

---

class: chapter-2, normal

# Jetpack とは

![Jetpack](jetpack.png)

Android アプリ開発のためのリソース

- ライブラリ (AndroidX)
  * バックポート (サポート ライブラリ)
  * アーキテクチャー コンポーネント
- アプリ開発に関するガイドライン
- 開発ツール

---

class: chapter-2, normal

# ライブラリ一覧

.large[
![一覧](list.png)
]

---

class: chapter-3, normal

# AndroidX への移行

![Migrate to AndroidX](refactor.png)

android.support.\* から androidx.\* への移行

Android Studio 3.2 以降のメニューの [Refactor] - [Migrate to AndroidX]

問題は [issuetracker.google.com](https://issuetracker.google.com) まで

サポート ライブラリ 28.1.0 は出ません

---

class: chapter-4, normal

# Android Dev Summit 関連動画

- [Fun with LiveData](https://www.youtube.com/watch?v=2rO4r-JOQtA)
- [The Room in the House](https://www.youtube.com/watch?v=sU-ot_Oz3AE)
- [Working with WorkManager](https://www.youtube.com/watch?v=83a4rYXsDs0)
- [Single Activity: Why, When, and How](https://www.youtube.com/watch?v=2k8x8V77CrU)


- [Level Up with Data Binding](https://www.youtube.com/watch?v=qc_QNQzMSCE)
- [Android Slices Best Practices](https://www.youtube.com/watch?v=JX87-Oxy0_E)
- [Use Android Text Like a Pro](https://www.youtube.com/watch?v=vXqwRhjd7b4)
- [Preferential Practices for Preferences](https://www.youtube.com/watch?v=PS9jhuHECEQ)
- [The Components of Material Design](https://www.youtube.com/watch?v=DPH3F0v1jB0)

???

---

class: chapter-5, hero, middle, center

# Fun with LiveData

---

class: chapter-5, normal

# ViewModel のライフサイクル

![ViewModel のライフサイクル](viewmodel-lifecycle.png)

Activity や Fragment は画面回転などでさまざまなライフサイクルを経て破棄・再生成される

画面に表示するデータは ViewModel に LiveData の形で保持する

UI は LiveData を observe する

```kotlin
   vm = ViewModelProviders.of(this)
       .get(MyViewModel::class.java)
   vm.myLiveData.observe(viewLifecycleOwner, Observer {
       // UI を更新
   })
```

---

class: chapter-5, normal

# アンチパターン

Transformations.map は重い処理に向かない<br>
→ LiveData を作るバックグラウンド処理の中ですべき

一つの LiveData を Repository の中に入れて複数の Activity から監視したりしない<br>
→ 基本的に ViewModel が LiveData を保持すべき<br>
　 複数の ViewModel が一つの LiveData のインスタンスを参照するのは避ける

UI に関係しない場合 LiveData の意味は薄い<br>
→ Executor / コルーチン / RxJava

---

class: chapter-10, hero, middle, center

# The Room in the House

---

class: chapter-10, normal

# Room これまでのまとめ

## 1.0

- コンパイル時にクエリ検証
- LiveData によるテーブル監視

## 1.1

- Write-Ahead Logging
- Paging のサポート

## 2.0

- AndroidX パッケージに移行

---

class: chapter-10, normal

# テキストで検索

```kotlin
@Entity
data class Mail(
    @PrimaryKey
    val id: Long,
    val subject: String,
    val body: String,
    val timestamp: Long
)
```

```kotlin
@Dao
interface MailDao {
    @Query("SELECT * FROM Mail WHERE subject LIKE '%' | :q | '%'")
    searchBySubject(q: String) List&lt;Mail&gt;

    @Query("SELECT * FROM Mail WHERE body LIKE '%' | :q | '%'")
    searchByBody(q: String) List&lt;Mail&gt;
}
```

---

class: chapter-10, normal

# 全文検索

.version[2.1.0-alpha01]

データベース内のテキストを全文検索

```kotlin
@Entity
@`Fts4`
data class Mail(
    @PrimaryKey
    val id: Long,
    val subject: String,
    val body: String,
    val timestamp: Long
)
```

```kotlin
@Dao
interface MailDao {
    @Query("SELECT * FROM Mail WHERE Mail `MATCH` :q")
    search(q: String) List&lt;Mail&gt;
}
```

???

- すべてのカラムが検索用にインデックスされる

---

class: chapter-10, normal

# データベースのインスタンス

アプリ全体で一つのインスタンスを参照するべき

例: シングルトン

```kotlin
@Database(entities = [...], version = 1)
abstract class MyDatabase : RoomDatabase() {

    companion object {
        private var instance: MyDatabase? = null
        fun getInstance() = instance ?:
            Room.databaseBuilder(MyDatabase::class.java, "my.db")
                .build().also { instance = it }
    }
}
```

インスタンスが違うとテーブル監視が動作しない

---

class: chapter-10, normal

# 複数インスタンス間のテーブル監視

.version[2.1.0-alpha01]

Room のデータベースは通常一つのインスタンスを参照する形で使う

サービスなどを使っていてプロセスを分けている場合、一つのインスタンスを参照できない
(= テーブル監視が動かない)

```kotlin
Room.databaseBuilder(context, MyDatabase::class.java, DB_NAME)
    .`enableMultiInstanceInvalidation()`
    .build()
```

プロセス間通信でテーブル監視を同期する

---

class: chapter-10, normal

# 複雑なクエリー

```kotlin
@Entity
data class Employee(
    @PrimaryKey val id: Long,
    val name: String,
    val teamId: Long)

@Entity
data class Team(
    @PrimaryKey val id: Long,
    val name: String)

data class EmployeeDetail(
    val id: Long,
    val name: String,
    val teamId: Long,
    val teamName: String)
```

```kotlin
    @Query("""
        SELECT e.id, e.name, e.teamId,t t.name AS teamName
        FROM Employee AS e LEFT JOIN Team AS t ON e.teamId = t.id
    """)
    fun employeeDetails(): List&lt;EmployeeDetail&gt;
```

---

class: chapter-10, normal

# ビュー

.version[2.1.0-alpha01]

```kotlin
@DatabaseView("""
    SELECT e.id, e.name, e.teamId,
           t.name AS teamName
    FROM Employee AS e LEFT JOIN Team AS t ON e.teamId = t.id
""")
data class EmployeeDetail(
    val id: Long,
    val name: String,
    val teamId: Long,
    val teamName: String
)
```

```kotlin
@Database(entities = [...], views = [EmployeeDetial::class], version = 1)
abstract class Mydatabase : RoomDatabase() {
    // …
}
```

???

- JOIN 以外でも大丈夫
- LiveData を返せば元になっているテーブルをすべて監視できる

---

class: chapter-10, normal

# コルーチン

.version[2.1.0-alpha03]

`androidx.room.room-coroutines:2.1.0-alpha03` が必要

```kotlin
@Dao
interface BookDao {
    @Insert
    `suspend` fun insert(book: Book)

    @Query("SELECT * FROM Book")
    `suspend` fun allBooks(): List&lt;Book&gt;
}
```

```kotlin
scope.launch {
    insert(Book(1, "芋粥"))
    val books = dao.allBooks()
    liveData.value = books
}
```

???

- 現状 一回の実行のみ (チャンネルは未サポート)
- 実行はバックグラウンド スレッドで行われる

???

---

class: chapter-11, hero, center, middle

# Working with WorkManager

---

class: chapter-11, normal

# WorkManager の基礎

時間のかかる処理を Worker として実装

```kotlin
class MyWorker(context : Context, params : WorkerParameters)
    : Worker(context, params) {
    override fun doWork(): Result {
        // 何か時間のかかる処理
        return Result.success()
    }
}
```

バックグラウンドで実行

```kotlin
    val work: OneTimeWorkRequest = OneTimeWorkRequestBuilder&lt;MyWork&gt;().build()
    WorkManager.getInstance().enqueue(work)
```

---

class: chapter-11, normal

# 実行条件

```kotlin
val constraints = Constraints.Builder()
        // デバイスがアイドル状態のとき
        .setRequiresDeviceIdle(true)
        // 充電につながれているとき
        .setRequiresCharging(true)
        // WiFi などに接続されているとき
        .setRequiredNetworkType(NetworkType.UNMETERED)
        .build()

val work = OneTimeWorkRequestBuilder&lt;MyWork&gt;()
      .setConstraints(constraints)
      .build()
```

```kotlin
val periodicWork = PeriodicWorkRequestBuilder&lt;MyWorker&gt;(7L, TimeUnit.DAYS)
      .build()
```

---

class: chapter-11, normal

#  ListenableWorker

.version[1.0.0-alpha10]

```kotlin
class MyWorker(context: Context, params: WorkerParameters)
    : Worker(context, params) {
    override fun doWork(): Result {
        // 何か時間のかかる処理
        return Result.success()
    }
}
```

```kotlin
class MyListenableWorker(context: Context, params: WorkerParameters)
    : ListenableWorker(context, params) {
    override fun startWork(): ListenableFuture&lt;Result&gt; {
        val future: ResolvableFuture&lt;Result&gt; = ResolvableFuture.create()
        // なんらかの方法でバックグラウンド実行
        thread {
            // 何か時間のかかる処理
            future.set(Result.success())
        }
        return future
    }
}
```

---

class: chapter-11, normal

# コルーチン

.version[1.0.0-alpha11]

```kotlin
class MyCoroutineWorker(context: Context, params: WorkerParameters)
    : CoroutineWorker(context, params) {

    override suspend fun doWork(): Result {
        // 何か時間のかかる処理
        // 中断関数を使う
        return Result.success()
    }
}
```

Dispatchers.DEFAULT で実行される

???

---

class: chapter-11, normal

# WorkInfo

Worker の状態を UI で表示したいとき

ViewModel など

```kotlin
private val work = OneTimeWorkRequestBuilder&lt;MyWorker&gt;().build()

val workInfo: LiveData&lt;WorkInfo&gt; = WorkManager.getInstance().getWorkInfoByIdLiveData(work.id)
```

Fragment など

```kotlin
workInfo.observe { info ->
    // UI を更新
}
```

---

class: chapter-11, normal

# Operation

.version[1.0.0-alpha11]

Worker をキューに入れるときの非同期処理を監視

```kotlin
val operation: Operation = workManager.enqueue(work)
```

UI に表示

```kotlin
operation.state.observe(this, Observer { state ->
    // UI を更新
})
```

コルーチン内で待ち合わせ

```kotlin
operation.await()
```

---

class: chapter-11, normal

# enqueueUniqueWork

.version[1.0.0-alpha11]

同じ Worker が重複するときどうするか指定

```kotlin
    workManager.enqueueUniqueWork("myWork", ExistingWorkPolicy.REPLACE, work)
```

定期実行の場合

```kotlin
    workManager.enqueueUniquePeriodicWork(
        "myPeriodicWork", ExistingPeriodicWorkPolicy.REPLACE, periodicWork)
```

- REPLACE (前の Worker を消して新しい Worker を登録)
- KEEP (前の Worker を残して新しい Worker は無視)
- APPEND (前の Worker に加えて新しい Worker も登録)

---

class: chapter-12, hero, center, middle

# Single Activity: <nobr>Why, When, and How</nobr>

---

class: chapter-12, normal

# Single Activity

Navigation ライブラリの考え方

Activity は基本的にアプリ全体で一つ

画面遷移は Fragment の切り替えで行う

---

class: chapter-12, normal

# Fragment の役割の変化

UI を保持・制御<br>
　

Activity のライフサイクルを分担<br>
　

データの読み込み・保持 (retainInstance = true)<br>
　

画面遷移 (Fragment Transaction)<br>
　
---

class: chapter-12, normal

# Fragment の役割の変化

UI を保持・制御<br>
　

Activity のライフサイクルを分担<br>
→ Lifecycle

データの読み込み・保持 (retainInstance = true)<br>
→ ViewModel

画面遷移 (Fragment Transaction)<br>
→ Navigation

---

class: chapter-12, normal

# Activity と Fragment

## Activity

プラットフォームからアプリへのエントリー ポイント

## Fragment

画面 (の一部)

---

class: chapter-12, normal

# それでも複数 Activity を使うべきとき

## タスクを分けるとき

```xml
&lt;activity
    android:name=".OpenDocumentActivity"
    android:documentLaunchMode="intoExisting"&gt;
    &lt;!-- intent-filter など --&gt;
&lt;/activity&gt;
```

- 開く: android:documentLaunchMode="intoExisting"
- 新規作成: android:documentLaunchMode="always"

## Picture in Picture

ビデオなど

---

class: chapter-12, normal

# Fragment のコンストラクター引数

Fragment のコンストラクターは必ず空であるべき

```kotlin
class MyFragment(`/* 空 */`) : Fragment() {
    // …
}
```

- Fragment はサポート ライブラリが生成・破棄する
  - 再生成時はリフレクションで空のコンストラクターを呼ぶ
- 引数を渡すには setArguments(Bundle) を使うべき

---

class: chapter-12, normal

# FragmentFactory

.version[fragment:1.0.0]

````kotlin
class MyFragmentFactory : FragmentFactory() {
    override fun instantiate(classLoader: ClassLoader, className: String, args: Bundle?): Fragment {
        return when (className) {
            "com.mycompany…" -> MyFragment(/* 引数を渡す */)
            else -> super.instantiate(classLoader, className, args)
        }
    }
}
```

```kotlin
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        supportFragmentManager.fragmentFactory = MyFragmentFactory()

        // setContentView など
    }
}
```


```kotlin
class MyFragment(`private val id: String`) : Fragment() {
    // …
}
```

???

- Navigation コンポーネントはまだ FragmentFactory をサポートしていない
  - サポート ライブラリ 28.0.0 を見ているから
  - FragmentNavigator の instantiateFragment をオーバーライドすればできる

---

class: chapter-17, normal

# まとめ

不具合報告・要望は [issuetracker.google.com](https://issuetracker.google.com/issues/new?component=192731&template=842428) から

[AOSP AndroidX Contribution Guide](https://android.googlesource.com/platform/frameworks/support/+/androidx-master-dev/README.md)

---

class: chapter-17, hero, middle, center

# ありがとうございました

    </textarea>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js">
    </script>
    <script>
      var hljs = remark.highlighter.engine;
    </script>
    <script src="http://gnab.github.io/remark/remark.language.js"></script>
    <script>
      var slideshow = remark.create({
        ratio: '16:10',
        highlightStyle: 'googlecode',
        highlightLanguage: 'remark',
        highlightLines: true,
        highlightSpans: true,
        navigation: {
          click: false,
          scroll: false,
          touch: true
        }
      });
    </script>
  </body>
</html>  
